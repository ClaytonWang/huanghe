from __future__ import annotations
from typing import List, Optional, Dict
from k8s.model.generic_mixin import GenericMixin
from k8s.model.v1_affinity import V1Affinity
from k8s.model.v1_container import V1Container
from k8s.model.v1_volume import V1Volume
from k8s.model.v1_toleration import V1Toleration
from k8s.const.workloads_const import IMAGE_PULL_POLICY_IF_NOT_PRESENT, SECRET_NAME_DOCKER_CONFIG, RESTART_POLICY_NEVER
from k8s.model.v1_local_object_reference import V1LocalObjectReference
from notebook.serializers import Volume

class V1PodSpec(GenericMixin):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    active_deadline_seconds: Optional[int]
    affinity: Optional[V1Affinity]
    automount_service_account_token: Optional[bool]
    containers: List[V1Container]
    # dns_config: Optional[V1PodDNSConfig]
    dns_policy: Optional[str]
    enable_service_links: Optional[bool]
    # ephemeral_containers: Optional[L]
    scheduler_name: Optional[str]
    init_containers: Optional[List[V1Container]]
    node_name: Optional[str]
    node_selector: Optional[Dict[str, str]]
    service_account: Optional[str]
    volumes: Optional[List[V1Volume]] = None
    tolerations: Optional[List[V1Toleration]]
    image_pull_secrets: Optional[List[V1LocalObjectReference]]
    restart_policy: Optional[str]

    openapi_types = {
        'active_deadline_seconds': 'int',
        'affinity': 'V1Affinity',
        'automount_service_account_token': 'bool',
        'containers': 'list[V1Container]',
        # 'dns_config': 'V1PodDNSConfig',
        'dns_policy': 'str',
        'enable_service_links': 'bool',
        # 'ephemeral_containers': 'list[V1EphemeralContainer]',
        # 'host_aliases': 'list[V1HostAlias]',
        # 'host_ipc': 'bool',
        # 'host_network': 'bool',
        # 'host_pid': 'bool',
        # 'host_users': 'bool',
        # 'hostname': 'str',
        'image_pull_secrets': 'list[V1LocalObjectReference]',
        'init_containers': 'list[V1Container]',
        'node_name': 'str',
        'node_selector': 'dict(str, str)',
        # 'os': 'V1PodOS',
        # 'overhead': 'dict(str, str)',
        # 'preemption_policy': 'str',
        # 'priority': 'int',
        # 'priority_class_name': 'str',
        # 'readiness_gates': 'list[V1PodReadinessGate]',
        'restart_policy': 'str',
        # 'runtime_class_name': 'str',
        'scheduler_name': 'str',
        # 'security_context': 'V1PodSecurityContext',
        'service_account': 'str',
        # 'service_account_name': 'str',
        # 'set_hostname_as_fqdn': 'bool',
        # 'share_process_namespace': 'bool',
        # 'subdomain': 'str',
        # 'termination_grace_period_seconds': 'int',
        'tolerations': 'list[V1Toleration]',
        # 'topology_spread_constraints': 'list[V1TopologySpreadConstraint]',
        'volumes': 'list[V1Volume]'
    }
    attribute_map = {
        'active_deadline_seconds': 'activeDeadlineSeconds',
        'affinity': 'affinity',
        'automount_service_account_token': 'automountServiceAccountToken',
        'containers': 'containers',
        'dns_config': 'dnsConfig',
        'dns_policy': 'dnsPolicy',
        'enable_service_links': 'enableServiceLinks',
        'ephemeral_containers': 'ephemeralContainers',
        'host_aliases': 'hostAliases',
        'host_ipc': 'hostIPC',
        'host_network': 'hostNetwork',
        'host_pid': 'hostPID',
        'host_users': 'hostUsers',
        'hostname': 'hostname',
        'image_pull_secrets': 'imagePullSecrets',
        'init_containers': 'initContainers',
        'node_name': 'nodeName',
        'node_selector': 'nodeSelector',
        'os': 'os',
        'overhead': 'overhead',
        'preemption_policy': 'preemptionPolicy',
        'priority': 'priority',
        'priority_class_name': 'priorityClassName',
        'readiness_gates': 'readinessGates',
        'restart_policy': 'restartPolicy',
        'runtime_class_name': 'runtimeClassName',
        'scheduler_name': 'schedulerName',
        'security_context': 'securityContext',
        'service_account': 'serviceAccount',
        'service_account_name': 'serviceAccountName',
        'set_hostname_as_fqdn': 'setHostnameAsFQDN',
        'share_process_namespace': 'shareProcessNamespace',
        'subdomain': 'subdomain',
        'termination_grace_period_seconds': 'terminationGracePeriodSeconds',
        'tolerations': 'tolerations',
        'topology_spread_constraints': 'topologySpreadConstraints',
        'volumes': 'volumes'
    }

    def add_pvc_volume_and_volume_mount(self, volumes: List[Volume]):
        if not self.volumes:
            self.volumes = []
        self.volumes.extend([V1Volume.pvc(volume.name) for volume in volumes])
        for container in self.containers:
            container.set_volume_mounts([v.dict() for v in volumes])
        return self

    def add_dshm(self):
        if not self.volumes:
            self.volumes = []
        self.volumes.extend([V1Volume.dshm()])
        for container in self.containers:
            container.extend_dshm_volume_mounts()
        return self

    def add_tolerations(self, tolerations: List[str]):
        if not self.tolerations:
            self.tolerations = []
        self.tolerations.extend([V1Toleration.exist(toleration) for toleration in tolerations])
        return self

    def add_image_pull_secrets(self, image_pull_secrets: List[str]):
        if not self.image_pull_secrets:
            self.image_pull_secrets = []
        self.image_pull_secrets.extend([V1LocalObjectReference.new(ims) for ims in image_pull_secrets])

    def set_restart_policy(self, restart_policy: str):
        self.restart_policy = restart_policy
        return self

    @classmethod
    def default(cls, name, image):
        return cls.new([V1Container.default(name=name, image=image)])

    @classmethod
    def notebook(cls, name: str, image: str, resource: Dict[str, str], envs: Dict[str, str], volumes,
                 tolerations: List[str]):
        c = V1Container.default(name=name, image=image)
        c.set_envs(envs).set_resources(resource).set_image_pull_policy(IMAGE_PULL_POLICY_IF_NOT_PRESENT)
        spec = cls.new([c])
        spec.add_pvc_volume_and_volume_mount(volumes).add_tolerations(tolerations).add_dshm().add_image_pull_secrets([SECRET_NAME_DOCKER_CONFIG])
        return spec


    @classmethod
    def vcjob(cls, name: str, image: str, resource: Dict[str, str], envs: Dict[str, str], volumes,
                 tolerations: List[str], command: List[str] = None, working_dir: Optional[str] = None):
        c = V1Container.default(name=name, image=image, command=command, working_dir=working_dir)
        c.set_envs(envs).set_resources(resource).set_image_pull_policy(IMAGE_PULL_POLICY_IF_NOT_PRESENT)
        spec = cls.new([c]).set_restart_policy(RESTART_POLICY_NEVER)
        spec.add_pvc_volume_and_volume_mount(volumes).add_tolerations(tolerations).add_dshm().add_image_pull_secrets([SECRET_NAME_DOCKER_CONFIG])
        return spec

    @staticmethod
    def new(containers: List[V1Container], volumes: Optional[List[V1Volume]] = None):
        return V1PodSpec(containers=containers, volumes=volumes)



if __name__ == '__main__':
    s = V1PodSpec()
    s.to_dict()